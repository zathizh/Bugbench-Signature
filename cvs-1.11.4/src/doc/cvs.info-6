This is cvs.info, produced by makeinfo version 4.2 from cvs.texinfo.

START-INFO-DIR-ENTRY
* CVS: (cvs).          Concurrent Versions System
END-INFO-DIR-ENTRY

   Copyright (C) 1992, 1993 Signum Support AB Copyright (C) 1993, 1994
Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.


File: cvs.info,  Node: commit,  Next: diff,  Prev: checkout,  Up: CVS commands

commit--Check files into the repository
=======================================

   * Synopsis: commit [-lnRf] [-m 'log_message' | -F file] [-r
     revision] [files...]

   * Requires: working directory, repository.

   * Changes: repository.

   * Synonym: ci

   Use `commit' when you want to incorporate changes from your working
source files into the source repository.

   If you don't specify particular files to commit, all of the files in
your working current directory are examined.  `commit' is careful to
change in the repository only those files that you have really changed.
By default (or if you explicitly specify the `-R' option), files in
subdirectories are also examined and committed if they have changed;
you can use the `-l' option to limit `commit' to the current directory
only.

   `commit' verifies that the selected files are up to date with the
current revisions in the source repository; it will notify you, and
exit without committing, if any of the specified files must be made
current first with `update' (*note update::).  `commit' does not call
the `update' command for you, but rather leaves that for you to do when
the time is right.

   When all is well, an editor is invoked to allow you to enter a log
message that will be written to one or more logging programs (*note
modules::, and *note loginfo::) and placed in the RCS file inside the
repository.  This log message can be retrieved with the `log' command;
see *Note log::.  You can specify the log message on the command line
with the `-m MESSAGE' option, and thus avoid the editor invocation, or
use the `-F FILE' option to specify that the argument file contains the
log message.

* Menu:

* commit options::              commit options
* commit examples::             commit examples


File: cvs.info,  Node: commit options,  Next: commit examples,  Up: commit

commit options
--------------

   These standard options are supported by `commit' (*note Common
options::, for a complete description of them):

`-l'
     Local; run only in current working directory.

`-n'
     Do not run any module program.

`-R'
     Commit directories recursively.  This is on by default.

`-r REVISION'
     Commit to REVISION.  REVISION must be either a branch, or a
     revision on the main trunk that is higher than any existing
     revision number (*note Assigning revisions::).  You cannot commit
     to a specific revision on a branch.

   `commit' also supports these options:

`-F FILE'
     Read the log message from FILE, instead of invoking an editor.

`-f'
     Note that this is not the standard behavior of the `-f' option as
     defined in *Note Common options::.

     Force CVS to commit a new revision even if you haven't made any
     changes to the file.  If the current revision of FILE is 1.7, then
     the following two commands are equivalent:

          $ cvs commit -f FILE
          $ cvs commit -r 1.8 FILE

     The `-f' option disables recursion (i.e., it implies `-l').  To
     force CVS to commit a new revision for all files in all
     subdirectories, you must use `-f -R'.

`-m MESSAGE'
     Use MESSAGE as the log message, instead of invoking an editor.


File: cvs.info,  Node: commit examples,  Prev: commit options,  Up: commit

commit examples
---------------

Committing to a branch
......................

   You can commit to a branch revision (one that has an even number of
dots) with the `-r' option.  To create a branch revision, use the `-b'
option of the `rtag' or `tag' commands (*note Branching and merging::).
Then, either `checkout' or `update' can be used to base your sources
on the newly created branch.  From that point on, all `commit' changes
made within these working sources will be automatically added to a
branch revision, thereby not disturbing main-line development in any
way.  For example, if you had to create a patch to the 1.2 version of
the product, even though the 2.0 version is already under development,
you might do:

     $ cvs rtag -b -r FCS1_2 FCS1_2_Patch product_module
     $ cvs checkout -r FCS1_2_Patch product_module
     $ cd product_module
     [[ hack away ]]
     $ cvs commit

This works automatically since the `-r' option is sticky.

Creating the branch after editing
.................................

   Say you have been working on some extremely experimental software,
based on whatever revision you happened to checkout last week.  If
others in your group would like to work on this software with you, but
without disturbing main-line development, you could commit your change
to a new branch.  Others can then checkout your experimental stuff and
utilize the full benefit of CVS conflict resolution.  The scenario might
look like:

     [[ hacked sources are present ]]
     $ cvs tag -b EXPR1
     $ cvs update -r EXPR1
     $ cvs commit

   The `update' command will make the `-r EXPR1' option sticky on all
files.  Note that your changes to the files will never be removed by the
`update' command.  The `commit' will automatically commit to the
correct branch, because the `-r' is sticky.  You could also do like
this:

     [[ hacked sources are present ]]
     $ cvs tag -b EXPR1
     $ cvs commit -r EXPR1

but then, only those files that were changed by you will have the `-r
EXPR1' sticky flag.  If you hack away, and commit without specifying
the `-r EXPR1' flag, some files may accidentally end up on the main
trunk.

   To work with you on the experimental change, others would simply do

     $ cvs checkout -r EXPR1 whatever_module


File: cvs.info,  Node: diff,  Next: export,  Prev: commit,  Up: CVS commands

diff--Show differences between revisions
========================================

   * Synopsis: diff [-lR] [-k kflag] [format_options] [[-r rev1 | -D
     date1] [-r rev2 |  -D date2]] [files...]

   * Requires: working directory, repository.

   * Changes: nothing.

   The `diff' command is used to compare different revisions of files.
The default action is to compare your working files with the revisions
they were based on, and report any differences that are found.

   If any file names are given, only those files are compared.  If any
directories are given, all files under them will be compared.

   The exit status for diff is different than for other CVS commands;
for details *Note Exit status::.

* Menu:

* diff options::                diff options
* diff examples::               diff examples


File: cvs.info,  Node: diff options,  Next: diff examples,  Up: diff

diff options
------------

   These standard options are supported by `diff' (*note Common
options::, for a complete description of them):

`-D DATE'
     Use the most recent revision no later than DATE.  See `-r' for how
     this affects the comparison.

`-k KFLAG'
     Process keywords according to KFLAG.  See *Note Keyword
     substitution::.

`-l'
     Local; run only in current working directory.

`-R'
     Examine directories recursively.  This option is on by default.

`-r TAG'
     Compare with revision TAG.  Zero, one or two `-r' options can be
     present.  With no `-r' option, the working file will be compared
     with the revision it was based on.  With one `-r', that revision
     will be compared to your current working file.  With two `-r'
     options those two revisions will be compared (and your working
     file will not affect the outcome in any way).

     One or both `-r' options can be replaced by a `-D DATE' option,
     described above.

   The following options specify the format of the output.  They have
the same meaning as in GNU diff.  Most options have two equivalent
names, one of which is a single letter preceded by `-', and the other
of which is a long name preceded by `--'.

`-LINES'
     Show LINES (an integer) lines of context.  This option does not
     specify an output format by itself; it has no effect unless it is
     combined with `-c' or `-u'.  This option is obsolete.  For proper
     operation, `patch' typically needs at least two lines of context.

`-a'
     Treat all files as text and compare them line-by-line, even if they
     do not seem to be text.

`-b'
     Ignore trailing white space and consider all other sequences of
     one or more white space characters to be equivalent.

`-B'
     Ignore changes that just insert or delete blank lines.

`--binary'
     Read and write data in binary mode.

`--brief'
     Report only whether the files differ, not the details of the
     differences.

`-c'
     Use the context output format.

`-C LINES'
`--context[=LINES]'
     Use the context output format, showing LINES (an integer) lines of
     context, or three if LINES is not given.  For proper operation,
     `patch' typically needs at least two lines of context.

`--changed-group-format=FORMAT'
     Use FORMAT to output a line group containing differing lines from
     both files in if-then-else format.  *Note Line group formats::.

`-d'
     Change the algorithm to perhaps find a smaller set of changes.
     This makes `diff' slower (sometimes much slower).

`-e'
`--ed'
     Make output that is a valid `ed' script.

`--expand-tabs'
     Expand tabs to spaces in the output, to preserve the alignment of
     tabs in the input files.

`-f'
     Make output that looks vaguely like an `ed' script but has changes
     in the order they appear in the file.

`-F REGEXP'
     In context and unified format, for each hunk of differences, show
     some of the last preceding line that matches REGEXP.

`--forward-ed'
     Make output that looks vaguely like an `ed' script but has changes
     in the order they appear in the file.

`-H'
     Use heuristics to speed handling of large files that have numerous
     scattered small changes.

`--horizon-lines=LINES'
     Do not discard the last LINES lines of the common prefix and the
     first LINES lines of the common suffix.

`-i'
     Ignore changes in case; consider upper- and lower-case letters
     equivalent.

`-I REGEXP'
     Ignore changes that just insert or delete lines that match REGEXP.

`--ifdef=NAME'
     Make merged if-then-else output using NAME.

`--ignore-all-space'
     Ignore white space when comparing lines.

`--ignore-blank-lines'
     Ignore changes that just insert or delete blank lines.

`--ignore-case'
     Ignore changes in case; consider upper- and lower-case to be the
     same.

`--ignore-matching-lines=REGEXP'
     Ignore changes that just insert or delete lines that match REGEXP.

`--ignore-space-change'
     Ignore trailing white space and consider all other sequences of
     one or more white space characters to be equivalent.

`--initial-tab'
     Output a tab rather than a space before the text of a line in
     normal or context format.  This causes the alignment of tabs in
     the line to look normal.

`-L LABEL'
     Use LABEL instead of the file name in the context format and
     unified format headers.

`--label=LABEL'
     Use LABEL instead of the file name in the context format and
     unified format headers.

`--left-column'
     Print only the left column of two common lines in side by side
     format.

`--line-format=FORMAT'
     Use FORMAT to output all input lines in if-then-else format.
     *Note Line formats::.

`--minimal'
     Change the algorithm to perhaps find a smaller set of changes.
     This makes `diff' slower (sometimes much slower).

`-n'
     Output RCS-format diffs; like `-f' except that each command
     specifies the number of lines affected.

`-N'
`--new-file'
     In directory comparison, if a file is found in only one directory,
     treat it as present but empty in the other directory.

`--new-group-format=FORMAT'
     Use FORMAT to output a group of lines taken from just the second
     file in if-then-else format.  *Note Line group formats::.

`--new-line-format=FORMAT'
     Use FORMAT to output a line taken from just the second file in
     if-then-else format.  *Note Line formats::.

`--old-group-format=FORMAT'
     Use FORMAT to output a group of lines taken from just the first
     file in if-then-else format.  *Note Line group formats::.

`--old-line-format=FORMAT'
     Use FORMAT to output a line taken from just the first file in
     if-then-else format.  *Note Line formats::.

`-p'
     Show which C function each change is in.

`--rcs'
     Output RCS-format diffs; like `-f' except that each command
     specifies the number of lines affected.

`--report-identical-files'
`-s'
     Report when two files are the same.

`--show-c-function'
     Show which C function each change is in.

`--show-function-line=REGEXP'
     In context and unified format, for each hunk of differences, show
     some of the last preceding line that matches REGEXP.

`--side-by-side'
     Use the side by side output format.

`--speed-large-files'
     Use heuristics to speed handling of large files that have numerous
     scattered small changes.

`--suppress-common-lines'
     Do not print common lines in side by side format.

`-t'
     Expand tabs to spaces in the output, to preserve the alignment of
     tabs in the input files.

`-T'
     Output a tab rather than a space before the text of a line in
     normal or context format.  This causes the alignment of tabs in
     the line to look normal.

`--text'
     Treat all files as text and compare them line-by-line, even if they
     do not appear to be text.

`-u'
     Use the unified output format.

`--unchanged-group-format=FORMAT'
     Use FORMAT to output a group of common lines taken from both files
     in if-then-else format.  *Note Line group formats::.

`--unchanged-line-format=FORMAT'
     Use FORMAT to output a line common to both files in if-then-else
     format.  *Note Line formats::.

`-U LINES'
`--unified[=LINES]'
     Use the unified output format, showing LINES (an integer) lines of
     context, or three if LINES is not given.  For proper operation,
     `patch' typically needs at least two lines of context.

`-w'
     Ignore white space when comparing lines.

`-W COLUMNS'
`--width=COLUMNS'
     Use an output width of COLUMNS in side by side format.

`-y'
     Use the side by side output format.

* Menu:

* Line group formats::          Line group formats
* Line formats::                Line formats


File: cvs.info,  Node: Line group formats,  Next: Line formats,  Up: diff options

Line group formats
..................

   Line group formats let you specify formats suitable for many
applications that allow if-then-else input, including programming
languages and text formatting languages.  A line group format specifies
the output format for a contiguous group of similar lines.

   For example, the following command compares the TeX file `myfile'
with the original version from the repository, and outputs a merged
file in which old regions are surrounded by `\begin{em}'-`\end{em}'
lines, and new regions are surrounded by `\begin{bf}'-`\end{bf}' lines.

     cvs diff \
        --old-group-format='\begin{em}
     %<\end{em}
     ' \
        --new-group-format='\begin{bf}
     %>\end{bf}
     ' \
        myfile

   The following command is equivalent to the above example, but it is a
little more verbose, because it spells out the default line group
formats.

     cvs diff \
        --old-group-format='\begin{em}
     %<\end{em}
     ' \
        --new-group-format='\begin{bf}
     %>\end{bf}
     ' \
        --unchanged-group-format='%=' \
        --changed-group-format='\begin{em}
     %<\end{em}
     \begin{bf}
     %>\end{bf}
     ' \
        myfile

   Here is a more advanced example, which outputs a diff listing with
headers containing line numbers in a "plain English" style.

     cvs diff \
        --unchanged-group-format='' \
        --old-group-format='-------- %dn line%(n=1?:s) deleted at %df:
     %<' \
        --new-group-format='-------- %dN line%(N=1?:s) added after %de:
     %>' \
        --changed-group-format='-------- %dn line%(n=1?:s) changed at %df:
     %<-------- to:
     %>' \
        myfile

   To specify a line group format, use one of the options listed below.
You can specify up to four line group formats, one for each kind of
line group.  You should quote FORMAT, because it typically contains
shell metacharacters.

`--old-group-format=FORMAT'
     These line groups are hunks containing only lines from the first
     file.  The default old group format is the same as the changed
     group format if it is specified; otherwise it is a format that
     outputs the line group as-is.

`--new-group-format=FORMAT'
     These line groups are hunks containing only lines from the second
     file.  The default new group format is same as the the changed
     group format if it is specified; otherwise it is a format that
     outputs the line group as-is.

`--changed-group-format=FORMAT'
     These line groups are hunks containing lines from both files.  The
     default changed group format is the concatenation of the old and
     new group formats.

`--unchanged-group-format=FORMAT'
     These line groups contain lines common to both files.  The default
     unchanged group format is a format that outputs the line group
     as-is.

   In a line group format, ordinary characters represent themselves;
conversion specifications start with `%' and have one of the following
forms.

`%<'
     stands for the lines from the first file, including the trailing
     newline.  Each line is formatted according to the old line format
     (*note Line formats::).

`%>'
     stands for the lines from the second file, including the trailing
     newline.  Each line is formatted according to the new line format.

`%='
     stands for the lines common to both files, including the trailing
     newline.  Each line is formatted according to the unchanged line
     format.

`%%'
     stands for `%'.

`%c'C''
     where C is a single character, stands for C.  C may not be a
     backslash or an apostrophe.  For example, `%c':'' stands for a
     colon, even inside the then-part of an if-then-else format, which
     a colon would normally terminate.

`%c'\O''
     where O is a string of 1, 2, or 3 octal digits, stands for the
     character with octal code O.  For example, `%c'\0'' stands for a
     null character.

`FN'
     where F is a `printf' conversion specification and N is one of the
     following letters, stands for N's value formatted with F.

    `e'
          The line number of the line just before the group in the old
          file.

    `f'
          The line number of the first line in the group in the old
          file; equals E + 1.

    `l'
          The line number of the last line in the group in the old file.

    `m'
          The line number of the line just after the group in the old
          file; equals L + 1.

    `n'
          The number of lines in the group in the old file; equals L -
          F + 1.

    `E, F, L, M, N'
          Likewise, for lines in the new file.

     The `printf' conversion specification can be `%d', `%o', `%x', or
     `%X', specifying decimal, octal, lower case hexadecimal, or upper
     case hexadecimal output respectively.  After the `%' the following
     options can appear in sequence: a `-' specifying
     left-justification; an integer specifying the minimum field width;
     and a period followed by an optional integer specifying the
     minimum number of digits.  For example, `%5dN' prints the number
     of new lines in the group in a field of width 5 characters, using
     the `printf' format `"%5d"'.

`(A=B?T:E)'
     If A equals B then T else E.  A and B are each either a decimal
     constant or a single letter interpreted as above.  This format
     spec is equivalent to T if A's value equals B's; otherwise it is
     equivalent to E.

     For example, `%(N=0?no:%dN) line%(N=1?:s)' is equivalent to `no
     lines' if N (the number of lines in the group in the the new file)
     is 0, to `1 line' if N is 1, and to `%dN lines' otherwise.


File: cvs.info,  Node: Line formats,  Prev: Line group formats,  Up: diff options

Line formats
............

   Line formats control how each line taken from an input file is
output as part of a line group in if-then-else format.

   For example, the following command outputs text with a one-column
change indicator to the left of the text.  The first column of output
is `-' for deleted lines, `|' for added lines, and a space for
unchanged lines.  The formats contain newline characters where newlines
are desired on output.

     cvs diff \
        --old-line-format='-%l
     ' \
        --new-line-format='|%l
     ' \
        --unchanged-line-format=' %l
     ' \
        myfile

   To specify a line format, use one of the following options.  You
should quote FORMAT, since it often contains shell metacharacters.

`--old-line-format=FORMAT'
     formats lines just from the first file.

`--new-line-format=FORMAT'
     formats lines just from the second file.

`--unchanged-line-format=FORMAT'
     formats lines common to both files.

`--line-format=FORMAT'
     formats all lines; in effect, it sets all three above options
     simultaneously.

   In a line format, ordinary characters represent themselves;
conversion specifications start with `%' and have one of the following
forms.

`%l'
     stands for the the contents of the line, not counting its trailing
     newline (if any).  This format ignores whether the line is
     incomplete.

`%L'
     stands for the the contents of the line, including its trailing
     newline (if any).  If a line is incomplete, this format preserves
     its incompleteness.

`%%'
     stands for `%'.

`%c'C''
     where C is a single character, stands for C.  C may not be a
     backslash or an apostrophe.  For example, `%c':'' stands for a
     colon.

`%c'\O''
     where O is a string of 1, 2, or 3 octal digits, stands for the
     character with octal code O.  For example, `%c'\0'' stands for a
     null character.

`Fn'
     where F is a `printf' conversion specification, stands for the
     line number formatted with F.  For example, `%.5dn' prints the
     line number using the `printf' format `"%.5d"'.  *Note Line group
     formats::, for more about printf conversion specifications.

   The default line format is `%l' followed by a newline character.

   If the input contains tab characters and it is important that they
line up on output, you should ensure that `%l' or `%L' in a line format
is just after a tab stop (e.g. by preceding `%l' or `%L' with a tab
character), or you should use the `-t' or `--expand-tabs' option.

   Taken together, the line and line group formats let you specify many
different formats.  For example, the following command uses a format
similar to `diff''s normal format.  You can tailor this command to get
fine control over `diff''s output.

     cvs diff \
        --old-line-format='< %l
     ' \
        --new-line-format='> %l
     ' \
        --old-group-format='%df%(f=l?:,%dl)d%dE
     %<' \
        --new-group-format='%dea%dF%(F=L?:,%dL)
     %>' \
        --changed-group-format='%df%(f=l?:,%dl)c%dF%(F=L?:,%dL)
     %<---
     %>' \
        --unchanged-group-format='' \
        myfile


File: cvs.info,  Node: diff examples,  Prev: diff options,  Up: diff

diff examples
-------------

   The following line produces a Unidiff (`-u' flag) between revision
1.14 and 1.19 of `backend.c'.  Due to the `-kk' flag no keywords are
substituted, so differences that only depend on keyword substitution
are ignored.

     $ cvs diff -kk -u -r 1.14 -r 1.19 backend.c

   Suppose the experimental branch EXPR1 was based on a set of files
tagged RELEASE_1_0.  To see what has happened on that branch, the
following can be used:

     $ cvs diff -r RELEASE_1_0 -r EXPR1

   A command like this can be used to produce a context diff between
two releases:

     $ cvs diff -c -r RELEASE_1_0 -r RELEASE_1_1 > diffs

   If you are maintaining ChangeLogs, a command like the following just
before you commit your changes may help you write the ChangeLog entry.
All local modifications that have not yet been committed will be
printed.

     $ cvs diff -u | less


File: cvs.info,  Node: export,  Next: history,  Prev: diff,  Up: CVS commands

export--Export sources from CVS, similar to checkout
====================================================

   * Synopsis: export [-flNnR] [-r rev|-D date] [-k subst] [-d dir]
     module...

   * Requires: repository.

   * Changes: current directory.

   This command is a variant of `checkout'; use it when you want a copy
of the source for module without the CVS administrative directories.
For example, you might use `export' to prepare source for shipment
off-site.  This command requires that you specify a date or tag (with
`-D' or `-r'), so that you can count on reproducing the source you ship
to others (and thus it always prunes empty directories).

   One often would like to use `-kv' with `cvs export'.  This causes
any keywords to be expanded such that an import done at some other site
will not lose the keyword revision information.  But be aware that
doesn't handle an export containing binary files correctly.  Also be
aware that after having used `-kv', one can no longer use the `ident'
command (which is part of the RCS suite--see ident(1)) which looks for
keyword strings.  If you want to be able to use `ident' you must not
use `-kv'.

* Menu:

* export options::              export options


File: cvs.info,  Node: export options,  Up: export

export options
--------------

   These standard options are supported by `export' (*note Common
options::, for a complete description of them):

`-D DATE'
     Use the most recent revision no later than DATE.

`-f'
     If no matching revision is found, retrieve the most recent
     revision (instead of ignoring the file).

`-l'
     Local; run only in current working directory.

`-n'
     Do not run any checkout program.

`-R'
     Export directories recursively.  This is on by default.

`-r TAG'
     Use revision TAG.

   In addition, these options (that are common to `checkout' and
`export') are also supported:

`-d DIR'
     Create a directory called DIR for the working files, instead of
     using the module name.  *Note checkout options::, for complete
     details on how CVS handles this flag.

`-k SUBST'
     Set keyword expansion mode (*note Substitution modes::).

`-N'
     Only useful together with `-d DIR'.  *Note checkout options::, for
     complete details on how CVS handles this flag.


File: cvs.info,  Node: history,  Next: import,  Prev: export,  Up: CVS commands

history--Show status of files and users
=======================================

   * Synopsis:     history [-report] [-flags] [-options args] [files...]

   * Requires: the file `$CVSROOT/CVSROOT/history'

   * Changes: nothing.

   CVS can keep a history file that tracks each use of the `checkout',
`commit', `rtag', `update', and `release' commands.  You can use
`history' to display this information in various formats.

   Logging must be enabled by creating the file
`$CVSROOT/CVSROOT/history'.

   *Warning:* `history' uses `-f', `-l', `-n', and `-p' in ways that
conflict with the normal use inside CVS (*note Common options::).

* Menu:

* history options::             history options


File: cvs.info,  Node: history options,  Up: history

history options
---------------

   Several options (shown above as `-report')  control  what kind of
report is generated:

`-c'
     Report on each time commit was used (i.e., each time the
     repository was modified).

`-e'
     Everything (all record types).  Equivalent to specifying `-x' with
     all record types.  Of course, `-e' will also include record types
     which are added in a future version of CVS; if you are writing a
     script which can only handle certain record types, you'll want to
     specify `-x'.

`-m MODULE'
     Report on a particular module.  (You can meaningfully use `-m'
     more than once on the command line.)

`-o'
     Report on checked-out modules.  This is the default report type.

`-T'
     Report on all tags.

`-x TYPE'
     Extract a particular set of record types TYPE from the CVS
     history.  The types are indicated by single letters, which you may
     specify in combination.

     Certain commands have a single record type:

    `F'
          release

    `O'
          checkout

    `E'
          export

    `T'
          rtag

     One of four record types may result from an update:

    `C'
          A merge was necessary but collisions were detected (requiring
          manual merging).

    `G'
          A merge was necessary and it succeeded.

    `U'
          A working file was copied from the repository.

    `W'
          The working copy of a file was deleted during update (because
          it was gone from the repository).

     One of three record types results from commit:

    `A'
          A file was added for the first time.

    `M'
          A file was modified.

    `R'
          A file was removed.

   The options shown as `-flags' constrain or expand the report without
requiring option arguments:

`-a'
     Show data for all users (the default is to show data only for the
     user executing `history').

`-l'
     Show last modification only.

`-w'
     Show only the records for modifications done from the same working
     directory where `history' is executing.

   The options shown as `-options ARGS' constrain the report based on
an argument:

`-b STR'
     Show data back to a record containing  the  string STR  in  either
     the module name, the file name, or the repository path.

`-D DATE'
     Show data since DATE.  This is slightly different from the normal
     use of `-D DATE', which selects the newest revision older than
     DATE.

`-f FILE'
     Show data for a particular file (you can specify several `-f'
     options on the same command line).  This is equivalent to
     specifying the file on the command line.

`-n MODULE'
     Show data for a particular module (you can specify several `-n'
     options on the same command line).

`-p REPOSITORY'
     Show data for a particular source repository  (you can specify
     several `-p' options on the same command line).

`-r REV'
     Show records referring to revisions since the revision or tag
     named REV appears in individual RCS files.  Each RCS file is
     searched for the revision or tag.

`-t TAG'
     Show records since tag TAG was last added to the history file.
     This differs from the `-r' flag above in that it reads only the
     history file, not the RCS files, and is much faster.

`-u NAME'
     Show records for user NAME.

`-z TIMEZONE'
     Show times in the selected records using the specified time zone
     instead of UTC.


File: cvs.info,  Node: import,  Next: log,  Prev: history,  Up: CVS commands

import--Import sources into CVS, using vendor branches
======================================================

   * Synopsis: import [-options] repository vendortag releasetag...

   * Requires: Repository, source distribution directory.

   * Changes: repository.

   Use `import' to incorporate an entire source distribution from an
outside source (e.g., a source vendor) into your source repository
directory.  You can use this command both for initial creation of a
repository, and for wholesale updates to the module from the outside
source.  *Note Tracking sources::, for a discussion on this subject.

   The REPOSITORY argument gives a directory name (or a path to a
directory) under the CVS root directory for repositories; if the
directory did not exist, import creates it.

   When you use import for updates to source that has been modified in
your source repository (since a prior import), it will notify you of
any files that conflict in the two branches of development; use
`checkout -j' to reconcile the differences, as import instructs you to
do.

   If CVS decides a file should be ignored (*note cvsignore::), it does
not import it and prints `I ' followed by the filename (*note import
output::, for a complete description of the output).

   If the file `$CVSROOT/CVSROOT/cvswrappers' exists, any file whose
names match the specifications in that file will be treated as packages
and the appropriate filtering will be performed on the file/directory
before being imported.  *Note Wrappers::.

   The outside source is saved in a first-level branch, by default
1.1.1.  Updates are leaves of this branch; for example, files from the
first imported collection of source will be revision 1.1.1.1, then
files from the first imported update will be revision 1.1.1.2, and so
on.

   At least three arguments are required.  REPOSITORY is needed to
identify the collection of source.  VENDORTAG is a tag for the entire
branch (e.g., for 1.1.1).  You must also specify at least one
RELEASETAG to identify the files at the leaves created each time you
execute `import'.

   Note that `import' does _not_ change the directory in which you
invoke it.  In particular, it does not set up that directory as a CVS
working directory; if you want to work with the sources import them
first and then check them out into a different directory (*note Getting
the source::).

* Menu:

* import options::              import options
* import output::               import output
* import examples::             import examples


File: cvs.info,  Node: import options,  Next: import output,  Up: import

import options
--------------

   This standard option is supported by `import' (*note Common
options::, for a complete description):

`-m MESSAGE'
     Use MESSAGE as log information, instead of invoking an editor.

   There are the following additional special options.

`-b BRANCH'
     See *Note Multiple vendor branches::.

`-k SUBST'
     Indicate the keyword expansion mode desired.  This setting will
     apply to all files created during the import, but not to any files
     that previously existed in the repository.  See *Note Substitution
     modes::, for a list of valid `-k' settings.

`-I NAME'
     Specify file names that should be ignored during import.  You can
     use this option repeatedly.  To avoid ignoring any files at all
     (even those ignored by default), specify `-I !'.

     NAME can be a file name pattern of the same type that you can
     specify in the `.cvsignore' file.  *Note cvsignore::.

`-W SPEC'
     Specify file names that should be filtered during import.  You can
     use this option repeatedly.

     SPEC can be a file name pattern of the same type that you can
     specify in the `.cvswrappers' file. *Note Wrappers::.


File: cvs.info,  Node: import output,  Next: import examples,  Prev: import options,  Up: import

import output
-------------

   `import' keeps you informed of its progress by printing a line for
each file, preceded by one character indicating the status of the file:

`U FILE'
     The file already exists in the repository and has not been locally
     modified; a new revision has been created (if necessary).

`N FILE'
     The file is a new file which has been added to the repository.

`C FILE'
     The file already exists in the repository but has been locally
     modified; you will have to merge the changes.

`I FILE'
     The file is being ignored (*note cvsignore::).

`L FILE'
     The file is a symbolic link; `cvs import' ignores symbolic links.
     People periodically suggest that this behavior should be changed,
     but if there is a consensus on what it should be changed to, it
     doesn't seem to be apparent.  (Various options in the `modules'
     file can be used to recreate symbolic links on checkout, update,
     etc.; *note modules::.)


File: cvs.info,  Node: import examples,  Prev: import output,  Up: import

import examples
---------------

   See *Note Tracking sources::, and *Note From files::.


File: cvs.info,  Node: log,  Next: rdiff,  Prev: import,  Up: CVS commands

log--Print out log information for files
========================================

   * Synopsis: log [options] [files...]

   * Requires: repository, working directory.

   * Changes: nothing.

   Display log information for files.  `log' used to call the RCS
utility `rlog'.  Although this is no longer true in the current
sources, this history determines the format of the output and the
options, which are not quite in the style of the other CVS commands.

   The output includes the location of the RCS file, the "head"
revision (the latest revision on the trunk), all symbolic names (tags)
and some other things.  For each revision, the revision number, the
author, the number of lines added/deleted and the log message are
printed.  All times are displayed in Coordinated Universal Time (UTC).
(Other parts of CVS print times in the local timezone).

   *Warning:* `log' uses `-R' in a way that conflicts with the normal
use inside CVS (*note Common options::).

* Menu:

* log options::                 log options
* log examples::                log examples


File: cvs.info,  Node: log options,  Next: log examples,  Up: log

log options
-----------

   By default, `log' prints all information that is available.  All
other options restrict the output.

`-b'
     Print information about the revisions on the default branch,
     normally the highest branch on the trunk.

`-d DATES'
     Print information about revisions with a checkin date/time in the
     range given by the semicolon-separated list of dates.  The date
     formats accepted are those accepted by the `-D' option to many
     other CVS commands (*note Common options::).  Dates can be
     combined into ranges as follows:

    `D1<D2'
    `D2>D1'
          Select the revisions that were deposited between D1 and D2.

    `<D'
    `D>'
          Select all revisions dated D or earlier.

    `D<'
    `>D'
          Select all revisions dated D or later.

    `D'
          Select the single, latest revision dated D or earlier.

     The `>' or `<' characters may be followed by `=' to indicate an
     inclusive range rather than an exclusive one.

     Note that the separator is a semicolon (;).

`-h'
     Print only the name of the RCS file, name of the file in the
     working directory, head, default branch, access list, locks,
     symbolic names, and suffix.

`-l'
     Local; run only in current working directory.  (Default is to run
     recursively).

`-N'
     Do not print the list of tags for this file.  This option can be
     very useful when your site uses a lot of tags, so rather than
     "more"'ing over 3 pages of tag information, the log information is
     presented without tags at all.

`-R'
     Print only the name of the RCS file.

`-rREVISIONS'
     Print information about revisions given in the comma-separated
     list REVISIONS of revisions and ranges.  The following table
     explains the available range formats:

    `REV1:REV2'
          Revisions REV1 to REV2 (which must be on the same branch).

    `REV1::REV2'
          The same, but excluding REV1.

    `:REV'
    `::REV'
          Revisions from the beginning of the branch up to and
          including REV.

    `REV:'
          Revisions starting with REV to the end of the branch
          containing REV.

    `REV::'
          Revisions starting just after REV to the end of the branch
          containing REV.

    `BRANCH'
          An argument that is a branch means all revisions on that
          branch.

    `BRANCH1:BRANCH2'
    `BRANCH1::BRANCH2'
          A range of branches means all revisions on the branches in
          that range.

    `BRANCH.'
          The latest revision in BRANCH.

     A bare `-r' with no revisions means the latest revision on the
     default branch, normally the trunk.  There can be no space between
     the `-r' option and its argument.

`-S'
     Suppress the header if no revisions are selected.

`-s STATES'
     Print information about revisions whose state attributes match one
     of the states given in the comma-separated list STATES.

`-t'
     Print the same as `-h', plus the descriptive text.

`-wLOGINS'
     Print information about revisions checked in by users with login
     names appearing in the comma-separated list LOGINS.  If LOGINS is
     omitted, the user's login is assumed.  There can be no space
     between the `-w' option and its argument.

   `log' prints the intersection of the revisions selected with the
options `-d', `-s', and `-w', intersected with the union of the
revisions selected by `-b' and `-r'.


File: cvs.info,  Node: log examples,  Prev: log options,  Up: log

log examples
------------

   Contributed examples are gratefully accepted.


File: cvs.info,  Node: rdiff,  Next: release,  Prev: log,  Up: CVS commands

rdiff--'patch' format diffs between releases
============================================

   * rdiff [-flags] [-V vn] [-r t|-D d [-r t2|-D d2]] modules...

   * Requires: repository.

   * Changes: nothing.

   * Synonym: patch

   Builds a Larry Wall format patch(1) file between two releases, that
can be fed directly into the `patch' program to bring an old release
up-to-date with the new release.  (This is one of the few CVS commands
that operates directly from the repository, and doesn't require a prior
checkout.) The diff output is sent to the standard output device.

   You can specify (using the standard `-r' and `-D' options) any
combination of one or two revisions or dates.  If only one revision or
date is specified, the patch file reflects differences between that
revision or date and the current head revisions in the RCS file.

   Note that if the software release affected is contained in more than
one directory, then it may be necessary to specify the `-p' option to
the `patch' command when patching the old sources, so that `patch' is
able to find the files that are located in other directories.

* Menu:

* rdiff options::               rdiff options
* rdiff examples::              rdiff examples


File: cvs.info,  Node: rdiff options,  Next: rdiff examples,  Up: rdiff

rdiff options
-------------

   These standard options are supported by `rdiff' (*note Common
options::, for a complete description of them):

`-D DATE'
     Use the most recent revision no later than DATE.

`-f'
     If no matching revision is found, retrieve the most recent
     revision (instead of ignoring the file).

`-l'
     Local; don't descend subdirectories.

`-R'
     Examine directories recursively.  This option is on by default.

`-r TAG'
     Use revision TAG.

   In addition to the above, these options are available:

`-c'
     Use the context diff format.  This is the default format.

`-s'
     Create a summary change report instead of a patch.  The summary
     includes information about files that were changed or added
     between the releases.  It is sent to the standard output device.
     This is useful for finding out, for example, which files have
     changed between two dates or revisions.

`-t'
     A diff of the top two revisions is sent to the standard output
     device.  This is most useful for seeing what the last change to a
     file was.

`-u'
     Use the unidiff format for the context diffs.  Remember that old
     versions of the `patch' program can't handle the unidiff format,
     so if you plan to post this patch to the net you should probably
     not use `-u'.

`-V VN'
     Expand keywords according to the rules current in RCS version VN
     (the expansion format changed with RCS version 5).  Note that this
     option is no longer accepted.  CVS will always expand keywords the
     way that RCS version 5 does.


File: cvs.info,  Node: rdiff examples,  Prev: rdiff options,  Up: rdiff

rdiff examples
--------------

   Suppose you receive mail from foo@example.net asking for an update
from release 1.2 to 1.4 of the tc compiler.  You have no such patches
on hand, but with CVS that can easily be fixed with a command such as
this:

     $ cvs rdiff -c -r FOO1_2 -r FOO1_4 tc | \
     $$ Mail -s 'The patches you asked for' foo@example.net

   Suppose you have made release 1.3, and forked a branch called
`R_1_3fix' for bugfixes.  `R_1_3_1' corresponds to release 1.3.1, which
was made some time ago.  Now, you want to see how much development has
been done on the branch.  This command can be used:

     $ cvs patch -s -r R_1_3_1 -r R_1_3fix module-name
     cvs rdiff: Diffing module-name
     File ChangeLog,v changed from revision 1.52.2.5 to 1.52.2.6
     File foo.c,v changed from revision 1.52.2.3 to 1.52.2.4
     File bar.h,v changed from revision 1.29.2.1 to 1.2


File: cvs.info,  Node: release,  Next: update,  Prev: rdiff,  Up: CVS commands

release--Indicate that a Module is no longer in use
===================================================

   * release [-d] directories...

   * Requires: Working directory.

   * Changes: Working directory, history log.

   This command is meant to safely cancel the effect of `cvs checkout'.
Since CVS doesn't lock files, it isn't strictly necessary to use this
command.  You can always simply delete your working directory, if you
like; but you risk losing changes you may have forgotten, and you leave
no trace in the CVS history file (*note history file::) that you've
abandoned your checkout.

   Use `cvs release' to avoid these problems.  This command checks that
no uncommitted changes are present; that you are executing it from
immediately above a CVS working directory; and that the repository
recorded for your files is the same as the repository defined in the
module database.

   If all these conditions are true, `cvs release' leaves a record of
its execution (attesting to your intentionally abandoning your
checkout) in the CVS history log.

* Menu:

* release options::             release options
* release output::              release output
* release examples::            release examples


File: cvs.info,  Node: release options,  Next: release output,  Up: release

release options
---------------

   The `release' command supports one command option:

`-d'
     Delete your working copy of the file if the release succeeds.  If
     this flag is not given your files will remain in your working
     directory.

     *Warning:*  The `release' command deletes all directories and
     files recursively.  This has the very serious side-effect that any
     directory that you have created inside your checked-out sources,
     and not added to the repository (using the `add' command; *note
     Adding files::) will be silently deleted--even if it is non-empty!


File: cvs.info,  Node: release output,  Next: release examples,  Prev: release options,  Up: release

release output
--------------

   Before `release' releases your sources it will print a one-line
message for any file that is not up-to-date.

   *Warning:*  Any new directories that you have created, but not added
to the CVS directory hierarchy with the `add' command (*note Adding
files::) will be silently ignored (and deleted, if `-d' is specified),
even if they contain files.

`U FILE'
`P FILE'
     There exists a newer revision of this file in the repository, and
     you have not modified your local copy of the file (`U' and `P'
     mean the same thing).

`A FILE'
     The file has been added to your private copy of the sources, but
     has not yet been committed to the repository.  If you delete your
     copy of the sources this file will be lost.

`R FILE'
     The file has been removed from your private copy of the sources,
     but has not yet been removed from the repository, since you have
     not yet committed the removal.  *Note commit::.

`M FILE'
     The file is modified in your working directory.  There might also
     be a newer revision inside the repository.

`? FILE'
     FILE is in your working directory, but does not correspond to
     anything in the source repository, and is not in the list of files
     for CVS to ignore (see the description of the `-I' option, and
     *note cvsignore::).  If you remove your working sources, this file
     will be lost.


File: cvs.info,  Node: release examples,  Prev: release output,  Up: release

release examples
----------------

   Release the `tc' directory, and delete your local working copy of
the files.

     $ cd ..         # You must stand immediately above the
                     # sources when you issue `cvs release'.
     $ cvs release -d tc
     You have [0] altered files in this repository.
     Are you sure you want to release (and delete) directory `tc': y
     $


File: cvs.info,  Node: update,  Prev: release,  Up: CVS commands

update--Bring work tree in sync with repository
===============================================

   * update [-ACdflPpR] [-I name] [-j rev [-j rev]] [-k kflag] [-r
     tag|-D date] [-W spec] files...

   * Requires: repository, working directory.

   * Changes: working directory.

   After you've run checkout to create your private copy of source from
the common repository, other developers will continue changing the
central source.  From time to time, when it is convenient in your
development process, you can use the `update' command from within your
working directory to reconcile your work with any revisions applied to
the source repository since your last checkout or update.

* Menu:

* update options::              update options
* update output::               update output

